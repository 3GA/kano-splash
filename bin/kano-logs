#!/usr/bin/env python

# kano-logs
#
# Copyright (C) 2014 Kano Computing Ltd.
# License: http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License v2
#
#
# View and manipulate kano logs

import os
import re
import sys
import json
import pydoc
import datetime
import argparse

if __name__ == '__main__' and __package__ is None:
    dir_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
    if dir_path != '/usr':
        sys.path.insert(0, dir_path)

import kano.logging as logging
from kano.logging import logger
from kano.colours import decorate_string, decorate_with_preset
from kano.utils import enforce_root

def show_logs(app=None):
    logfiles = []
    for d in [logging.SYSTEM_LOGS_DIR, logging.USER_LOGS_DIR]:
        if app != None:
            path = os.path.join(d, app + ".log")
            if os.path.exists(path):
                logfiles.append(path)
        else:
            if os.path.exists(d):
                for log in os.listdir(d):
                    logfiles.append(os.path.join(d, log))

    output = ""
    for log in logfiles:
        output += "{}: {}\n".format(decorate_string("LOGFILE", "green"), log)
        app_name = re.sub(r"\.log$", "", log)
        with open(log, "r") as f:
            for line in f:
                data = json.loads(line)

                dt = datetime.datetime.fromtimestamp(data["time"])
                time = dt.strftime('%Y-%m-%d %H:%M:%S')
                output += "{} {}[{}] {} {}\n".format(
                    decorate_string(time, "cyan"),
                    os.path.basename(app_name),
                    decorate_string(data["pid"], "yellow"),
                    decorate_with_preset(data["level"], data["level"]),
                    data["message"]
                )
        output += "\n"

    if len(output) > 0:
        pydoc.pipepager(output, cmd='less -R')

def process_args():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(
        title="Subcommands",
        description="These are the commands you can use with kano-logs",
        help="the available subcommands"
    )

    show = subparsers.add_parser("show", help="display logs")
    show.set_defaults(which="show")
    show.add_argument(
        "app",
        type=str,
        help="the application to show logs for",
        default=None,
        nargs="?"
    )

    config = subparsers.add_parser("config", help="configure logging")
    config.set_defaults(which="config")
    config.add_argument(
        "-l", "--log-level",
        help="set log level",
        type=str,
        nargs="?"
    )

    config.add_argument(
        "-o", "--output-level",
        help="set output level",
        type=str,
        nargs="?"
    )

    config.add_argument(
        "-s", "--show-value",
        help="print a configuration option",
        type=str
    )

    args = parser.parse_args()
    return vars(args)

def main():
    args = process_args()

    if args["which"] == "show":
        show_logs(args["app"])
    elif args["which"] == "config":
        if args["log_level"] == None and args["output_level"] == None and \
           args["show_value"] == None:
            ll = logger.get_log_level()
            dl = logger.get_output_level()
            print "Logging set to {}".format(decorate_with_preset(ll, ll))
            print "Debugging set to {}".format(decorate_with_preset(dl, dl))
            return 0

        if args["show_value"] is not None:
            if args["show_value"] == "log_level":
                print logger.get_log_level()
            elif args["show_value"] == "output_level":
                print logger.get_output_level()
            return 0

        enforce_root("ERROR: Must be root to change the modes")

        if args["log_level"] is not None:
            logging.set_system_log_level(args["log_level"])

        if args["output_level"] is not None:
            logging.set_system_output_level(args["output_level"])

    return 0

if __name__ == "__main__":
    sys.exit(main())
